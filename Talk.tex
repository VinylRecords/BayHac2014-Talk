\documentclass[12pt]{beamer}

% for themes, etc.
\mode<presentation>
{ \usetheme{Copenhagen}
  \usecolortheme{seahorse}{}
}
\setbeamertemplate{itemize items}[default]
\setbeamertemplate{enumerate items}[default]


\usepackage{times}  % fonts are up to you
\usepackage{proof}
\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{stmaryrd}

\lstset{columns=fullflexible}
\lstset{
  literate={->}{$\to$ }{1}
           {:E}{$\in$ }{1}
           {[|}{$\llbracket$ }{1}
           {|]}{$\llbracket$ }{1},
  escapeinside=||,
  moredelim=**[is][\color{red}]{@}{@},
}
\lstset{language=Haskell}

% these will be used later in the title page
\title{Programming in Vinyl}
\author{Jon Sterling\\
    FOBO
}

\begin{document}

% this prints title, author etc. info from above
\begin{frame}
\titlepage
\end{frame}

\section{Extensible Records and Row Polymorphism}

\begin{frame}
  \frametitle{Records in GHC 7.8}
  Haskell Records are nominally typed. \pause
  \[
    \infer{
      \Gamma\nvdash x : N.T
    }{
      \Gamma\vdash M.S \leadsto \{ \vec{rs} \} &
      \Gamma\vdash N.T \leadsto \{ \vec{rs} \} &
      \Gamma\vdash x : M.S
    }
  \]
\end{frame}

\begin{frame}[fragile]
  \frametitle{Records in GHC 7.8}
  Records may not share field names. \pause

  \begin{lstlisting}
    data R = R { x :: X } |\pause|
    data R' = R' { x :: X } -- ^ Error
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Records in GHC 7.8}
  \only<1>{Records are...}
  \only<2>{\Large\centerline{anticompositional}}
\end{frame}

\begin{frame}
  \frametitle{Records in Standard ML}
  \pause
  \Large\centerline{slightly better}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Records in Standard ML}
  \pause
  Records are permutative, and not nominal.\pause
  \[
    \infer{\Gamma\vdash x:\{\vec{ts}\}}{
      \Gamma\vdash x:\{\vec{ss}\} &
      \Gamma\vdash ts\in\mathsf{permutations}(\vec{ss})
    }
  \]
\end{frame}

\begin{frame}
  \frametitle{Records in OCaml}
  \only<1-4> {
  OCaml records are\pause
  \begin{itemize}
    \item structural\pause
    \item endowed with a subtyping relation\pause
    \item but more importantly...
  \end{itemize}
  }
  \only<5>{
    \Large\centerline{row polymorphic}
  }
\end{frame}

\begin{frame}
  \frametitle{Row Polymorphism}
  \pause
  \emph{Pick out the parts you care about, and quantify the rest.}

  \centerline{--- Someone wise}
\end{frame}

\begin{frame}
  \frametitle{Row Polymorphism}
  How do we express the type of a function which adds a field to a record?\pause
  \only<2>{
    \[
      \infer{ f(x) : \{a:A, b:B\} }{ x : \{a:A\} }
    \]
  }
  \only<3>{
    \Large\centerline{NOPE}
  }
  \only<4>{
    \[
      \infer{ f(x) : \{a:A, b:B; \vec{rs}\} }{ x : \{a:A; \vec{rs}\} }
    \]
  }
\end{frame}

\begin{frame}
  \frametitle{Row Polymorphism}\pause
  \begin{itemize}
    \item supports type inference\pause
    \item is compositional\pause
    \item is \textbf{modular}\pause
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Roll Your Own in Haskell}\pause
  \begin{lstlisting}
    data (s :: Symbol) ::: (t :: *) = Field |\pause|

    data Rec :: [*] -> * where |\pause|
      RNil :: Rec '[] |\pause|
      (:&) :: !t -> !(Rec rs) -> Rec ((s ::: t) ': rs)

    |\pause|
    class s :E (rs :: [*])|\pause|
    (=:) : s ::: t -> t -> Rec '[ s ::: t ]|\pause|
    (<+>) : Rec ss -> Rec ts -> Rec (ss ++ ts)
  \end{lstlisting}
\end{frame}
\begin{frame}
  \frametitle{Roll Your Own in Haskell}\pause
  \[
    \infer{
      f\, x :: (\text{"a"} ::: A\in\vec{rs}, \text{"b"} ::: B\in\vec{rs}) \implies \mathsf{Rec}\ \vec{rs}
    }{
      x :: \text{"a"} ::: A\in\vec{rs}\implies \mathsf{Rec}\ \vec{rs}
    }
  \]
\end{frame}

\section{Universes \`a la Tarski}

\begin{frame}
  \frametitle{Universes \`a la Tarski}\pause
  \begin{itemize}
    \item A type $\mathcal{U}$ of \textbf{codes} for types.
      \pause
    \item Function $\llbracket-\rrbracket_\mathcal{U} : \mathcal{U}\to\mathbf{Type}$.
      \pause
      \[
        \infer{
          \Gamma\vdash\llbracket s\rrbracket_\mathcal{U} : \mathbf{Type}
        }{
          \Gamma\vdash s : \mathcal{U}
        }
      \]
    \pause
    \item The Tarski universe $\mathcal{U}$ is a set, but the ambient universe $\mathbf{Type}$ may not necessarily be.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{An Example Universe}
  \pause
  Let $\mathcal{F}$ be the universe of finite sets:
  \pause
  \begin{itemize}
    \item Statics:
      \pause
      \[
        \infer{\Gamma\vdash\mathcal{F} : \mathbf{Type}}{}
        \qquad
        \infer{\Gamma\vdash\textsf{fin}(n) : \mathcal{F}}{\Gamma\vdash n : \mathbb{N}}
        \qquad
        \infer{\Gamma\vdash\llbracket s \rrbracket_\mathcal{F} : \mathbf{Type}}{\Gamma\vdash s : \mathcal{F}}
      \]
      \pause
    \item Dynamics:
      \[
        \infer{\Gamma\vdash\llbracket\textsf{fin}(n)\rrbracket_\mathcal{F} \mapsto \textsf{rec}_\mathbb{N}(n; s)}{}
      \]
  \end{itemize}
\end{frame}

\end{document}

